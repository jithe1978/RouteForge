pipeline {
  agent any
  options { timestamps(); ansiColor('xterm') }

  environment {
    AWS_DEFAULT_REGION = 'us-east-2'
    ACCOUNT_ID = '577999460012'
    ECR_FRONT = "${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/pdf-frontend"
    ECR_BACK  = "${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/pdf-backend"
    CHART_APP = 'charts/pdf-app'
    CHART_ING = 'charts/pdfapp-ingress'
    NAMESPACE = 'pdfapp'

    // >>> POINT HELM/KUBECTL AT YOUR KUBEADM CLUSTER <<<
    // Kube config on your laptop:
    KUBECONFIG = 'C:\\Users\\jithe\\.kube\\ec2.yaml'
    // Your working context name:
    KUBE_CONTEXT = 'ec2'
  }

  stages {

    stage('Checkout') { steps { checkout scm } }

    stage('Compute IMAGE_TAG') {
      steps {
        script {
          def sha  = powershell(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
          def date = powershell(returnStdout: true, script: 'Get-Date -Format "yyyyMMdd-HHmm"').trim()
          env.IMAGE_TAG = "${sha}-${date}"
        }
        powershell 'Write-Host "IMAGE_TAG = $Env:IMAGE_TAG"'
      }
    }

    stage('Echo Vars') {
      steps {
        powershell '''
          Write-Host "ECR_BACK   = $Env:ECR_BACK"
          Write-Host "ECR_FRONT  = $Env:ECR_FRONT"
          Write-Host "IMAGE_TAG  = $Env:IMAGE_TAG"
          Write-Host "KUBECONFIG = $Env:KUBECONFIG"
          Write-Host "KUBE_CONTEXT = $Env:KUBE_CONTEXT"
        '''
      }
    }

    stage('Login to ECR') {
      steps {
        // If you already have AWS CLI configured on the laptop user, you don't need withAWS.
        // Keep this if you're using Jenkins AWS Credentials named 'aws-creds'.
        withAWS(credentials: 'aws-creds', region: "${env.AWS_DEFAULT_REGION}") {
          powershell '''
            $ErrorActionPreference = "Stop"
            $acct = (aws sts get-caller-identity --query Account --output text)
            $registry = "$acct.dkr.ecr.$Env:AWS_DEFAULT_REGION.amazonaws.com"
            $pass = aws ecr get-login-password --region $Env:AWS_DEFAULT_REGION
            if (-not $pass) { throw "Empty ECR login password" }
            docker logout $registry 2>$null | Out-Null
            docker login $registry -u AWS -p $pass
          '''
        }
      }
    }

    stage('Build Backend Image') {
      steps {
        dir('backend') {
          powershell """
            docker build -t ${env.ECR_BACK}:${env.IMAGE_TAG} .
          """
        }
      }
    }

    stage('Build Frontend Image') {
      steps {
        dir('frontend') {
          powershell """
            docker build -t ${env.ECR_FRONT}:${env.IMAGE_TAG} .
          """
        }
      }
    }

    stage('Push Images') {
      steps {
        powershell """
          docker push ${env.ECR_BACK}:${env.IMAGE_TAG}
          docker push ${env.ECR_FRONT}:${env.IMAGE_TAG}
        """
      }
    }

    // >>> THIS REPLACES YOUR EKS UPDATE STEP <<<
    stage('Select kube context') {
      steps {
        powershell '''
          $ErrorActionPreference = "Stop"
          # Ensure kubectl talks to the right cluster/context
          kubectl config use-context $Env:KUBE_CONTEXT
          kubectl cluster-info
          kubectl get nodes
          helm version
        '''
      }
    }
stage('Generate ECR values (dockerconfigjson)') {
  steps {
    powershell '''
      $ErrorActionPreference = "Stop"

      $registry = "$Env:ACCOUNT_ID.dkr.ecr.$Env:AWS_DEFAULT_REGION.amazonaws.com"
      $pwd      = aws ecr get-login-password --region $Env:AWS_DEFAULT_REGION
      if (-not $pwd) { throw "Empty ECR login password" }

      # docker config JSON
      $auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("AWS:$pwd"))
      $cfg  = @{ auths = @{ $registry = @{ username="AWS"; password=$pwd; email="none"; auth=$auth } } } |
              ConvertTo-Json -Compress

      # base64 of the JSON (what Kubernetes expects under data[".dockerconfigjson"])
      $b64  = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($cfg))

      $out = @"
namespace: $Env:NAMESPACE
imagePullSecret:
  create: true
  name: ecr-pull
  dockerconfigjsonB64: $b64
"@
      $path = Join-Path $Env:WORKSPACE 'ecr-values.yaml'
      Set-Content -Path $path -Value $out -NoNewline -Encoding ascii
      Write-Host "Wrote $path"
    '''
  }
}

    stage('Deploy App (Helm)') {
      steps {
        powershell '''
          helm upgrade --install pdf-app $Env:CHART_APP `
            --namespace $Env:NAMESPACE `
            --kube-context $Env:KUBE_CONTEXT `
            --create-namespace `
            -f "$Env:WORKSPACE\\ecr-values.yaml" `
            --set images.frontend.repository="$Env:ECR_FRONT" `
            --set images.frontend.tag="$Env:IMAGE_TAG" `
            --set images.backend.repository="$Env:ECR_BACK" `
            --set images.backend.tag="$Env:IMAGE_TAG" `
            --wait --timeout 10m

          kubectl --context $Env:KUBE_CONTEXT -n $Env:NAMESPACE rollout status deploy/frontend --timeout=180s
          kubectl --context $Env:KUBE_CONTEXT -n $Env:NAMESPACE rollout status deploy/backend  --timeout=180s
        '''
      }
    }

    stage('Deploy Ingress (Helm)') {
      steps {
        powershell '''
          helm upgrade --install pdfapp-ingress $Env:CHART_ING `
          -n $Env:NAMESPACE `
          --kube-context $Env:KUBE_CONTEXT `
          --wait --timeout 5m
          '''
      }
    }
  }
stage('Install ingress-nginx controller') {
  steps {
    powershell '''
      $ErrorActionPreference = "Stop"
      helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx --force-update

      helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx `
        --namespace ingress-nginx `
        --kube-context $Env:KUBE_CONTEXT `
        --create-namespace `
        --set controller.service.type=NodePort `
        --set controller.service.nodePorts.http=30080 `
        --set controller.service.nodePorts.https=30443 `
        --set controller.replicaCount=2 `
        --wait --timeout 10m

      kubectl --context $Env:KUBE_CONTEXT -n ingress-nginx get svc ingress-nginx-controller
    '''
  }
}
  post {
    always {
      powershell 'docker image prune -f | Out-Null'
    }
  }
}