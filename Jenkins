pipeline {
  agent any
  environment {
    AWS_DEFAULT_REGION = 'us-east-2'
    ACCOUNT_ID = '577999460012'
    ECR_FRONT = "${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/pdf-frontend"
    ECR_BACK  = "${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/pdf-backend"
    CHART_APP = 'charts/pdf-app'      // <-- your new chart path
    CHART_ING = 'charts/ingress'      // <-- your existing ingress chart path
    NAMESPACE = 'pdfapp'
    EKS_CLUSTER = 'mern-app-cluster'   // <-- fill this in
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

stage('Compute IMAGE_TAG') {
  steps {
    script {
      def sha  = powershell(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
      def date = powershell(returnStdout: true, script: 'Get-Date -Format "yyyyMMdd-HHmm"').trim()
      env.IMAGE_TAG = "${sha}-${date}"
    }
    powershell 'Write-Host "IMAGE_TAG = $Env:IMAGE_TAG"'
  }
}

stage('Echo Vars') {
  steps {
    powershell '''
      Write-Host "ECR_BACK   = $Env:ECR_BACK"
      Write-Host "ECR_FRONT  = $Env:ECR_FRONT"
      Write-Host "IMAGE_TAG  = $Env:IMAGE_TAG"
    '''
  }
}


stage('Login to ECR') {
  steps {
    withAWS(credentials: 'aws-creds', region: "${env.AWS_DEFAULT_REGION}") {
      powershell '''
        $ErrorActionPreference = "Stop"

        $acct = (aws sts get-caller-identity --query Account --output text)
        $registry = "$acct.dkr.ecr.$Env:AWS_DEFAULT_REGION.amazonaws.com"

        $pass = aws ecr get-login-password --region $Env:AWS_DEFAULT_REGION
        if (-not $pass) { throw "Empty ECR login password" }

        docker logout $registry 2>$null | Out-Null
        docker login $registry -u AWS -p $pass
      '''
    }
  }
}

stage('Build Backend Image') {
  steps {
    dir('backend') {
      // Use Groovy interpolation (triple double-quotes)
      powershell """
        docker build -t ${env.ECR_BACK}:${env.IMAGE_TAG} .
      """
    }
  }
}


stage('Build Frontend Image') {
  steps {
    dir('frontend') {
      // Use Groovy interpolation (triple double-quotes)
      powershell """
        docker build -t ${env.ECR_FRONT}:${env.IMAGE_TAG} .
      """
    }
  }
}


stage('Push Images') {
  steps {
    powershell """
      docker push ${env.ECR_BACK}:${env.IMAGE_TAG}
      docker push ${env.ECR_FRONT}:${env.IMAGE_TAG}
    """
  }
}

    stage('Update kubeconfig') {
      steps {
        powershell '''
          $ErrorActionPreference = "Stop"
          aws eks update-kubeconfig --name $env:EKS_CLUSTER --region $env:AWS_DEFAULT_REGION
          kubectl version --client
          helm version
        '''
      }
    }


stage('Create Namespace') {
  steps {
    powershell '''
      $ErrorActionPreference = "Stop"
      
      # 1. Idempotently create the namespace
      kubectl create namespace $Env:NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
      
      # 2. Patch the namespace with Helm metadata to allow the subsequent Helm install
      kubectl annotate namespace $Env:NAMESPACE "meta.helm.sh/release-name=pdf-app" --overwrite
      kubectl annotate namespace $Env:NAMESPACE "meta.helm.sh/release-namespace=$Env:NAMESPACE" --overwrite
      kubectl label namespace $Env:NAMESPACE "app.kubernetes.io/managed-by=Helm" --overwrite
    '''
  }
}

// 2. Modified Deployment Stage (Safest Option)
stage('Deploy App (Helm)') {
  steps {
    powershell '''
      helm upgrade --install pdf-app charts/pdf-app -n $Env:NAMESPACE `
        --set images.frontend="$Env:ECR_FRONT:$Env:IMAGE_TAG" `
        --set images.backend="$Env:ECR_BACK:$Env:IMAGE_TAG" `
        --atomic --wait --timeout 5m
    '''
  }
}

    stage('Deploy Ingress (Helm)') {
      steps {
        powershell '''
          $ErrorActionPreference = "Stop"
          # Reuse your existing ingress chart + the PDF app values file at repo root
          helm upgrade --install pdfapp-ingress $env:CHART_ING -f pdfapp-ingress-values.yaml
          kubectl -n $env:NAMESPACE get ingress
        '''
      }
    }
  }
}